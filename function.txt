함수에 대하여 #1

1. 함수는 왜 쓰는가

- 반복적이고, 중복되는 프로그래밍을 피하기 위해서 사용한다.
- 단, 하나의 함수는 하나의 기능을 수행하는 형태로 만들어야한다.


2. 클로저(closure)란 무엇인가.
참고: https://shoark7.github.io/programming/python/closure-in-python

- 작은 범위에서는 함수의 중첩을 의미할 수 있지만, 함수 중첩은 closure이기 위한 필요 조건이지, 충분조건이 아님.
- 정확한 의미로는 '자신을 둘러싼 스코프의 상태값을 기억하는 함수'이다.
- 영단어 enclose : 담을 두르다. 처럼 관리와 책임을 담을 둘러 구분한다고 이해하면 쉽다.
- 클로저는 자신을 둘러싼 함수 스코프의 상태값을 참조하는데, 이 값은 함수가 메모리에서 사라져도 값이 유지된다.

조건! 어떤 함수가 클로저이기 위해서는 아래 조건을 만족해야한다.
(1) 해당 함수는 어떤 함수 내의 중첩된 함수여야한다.
(2) 해당 함수는 자신을 둘러싼(enclose) 함수 내의 상태값을 반드시 참조해야한다.
(3) 해당 함수를 둘러싼 함수는 이 함수를 반환해야한다.

장점! 
(1) 관리와 책임을 명확히 할 수 있음.
(2) 각 변수가 섞여 불필요한 충돌을 방지할 수 있음.
(3) 사용환경(context)에 맞게 임의대로 내부구조를 조정할 수 있음.

    기본 개념 :
    (1) 함수의 중첩(Function nesting) : 선언한 함수안에 또 다른 함수를 선언하는 것.
    

    (2) 일급 객체(First Class Object) : 해당 언어 내에서 일반적으로 다른 모든 개체에 통용가능한 동작이 지원되는 개체
      동작(operation)이란?
      / 함수의 인자로 전달
      / 함수의 반환값
      / 수정되고 할당되는 것
      => list, str, int등등 파이썬 함수의 인자로 전달/반환/수정/할당 되는 자료타입이 1급 객체(First Class Object)
        c언어에서 함수 인자로 함수의 포인터를 전달할 수 있지만, 함수의 이름을 전달할 수는 없다.
        기술적으로 포인터가 일급 객체라는 표현은 맞아도, 함수가 일급 객체라는 표현은 적절치않음.
        파이썬에서는 함수도 1급 객체이다. 함수에는 기본 자료타입들에 적용가능한 동작이 똑같이 적용가능하다.

        """
        def add(a, b):
            return a + b

        def execute(func, *args):
            return func(*args) # 2.

        f = add # 3.

        >>> execute(f, 3, 5) # 1.

        8
        """
        f라는 함수가 execute의 함수 인자로 전달되었고
        함수 내부의 인자로 받은 함수 func를 문제없이 사용하고 있으며
        add라는 원 함수의 이름에 f라는 새이름을 할당하였다.

        즉, 파이썬에서 함수는 1급 객체이다.

        이 특성이 있어야 Closure가 성립될 수 있다.

    (3) 파이썬의 nonlocal 스코프 
    """
    z = 3

    def outer(x):
        y = 10
        def inner():
            x = 1000
            return x

        return inner()

    print(outer(10))
    """

    파이썬에서 함수 중첩이 가능하다는 것을 확인했다. 그런데 위의 함수에는 x값에 대한 코드가 2번 제시됐다.
    처음은 함수 실행시에 받는 임의의 x이고, 다음은 inner함수 내에서 1000으로 초기화하는 변수 x 이다.
    예시처럼 함수를 호출할 경우, 최종 return 값인 inner 1000을 반환한다.

    inner 함수 입장에서 바라보면...
    (1) inner 함수 블록 안에 있는 영역은 local 스코프라고 불린다. 로컬 영역안의 모든 개체들은 inner의 제어 아래 있다.
    (2) outer의 안에 있되, inner의 밖에 있는 영역은 nonlocal스코프라고 불린다. outer의 y변수는 inner입장에서는 nonlocal스코프의 변수이다.
    (3) outer 함수 밖의 영역은 global스코프다. z 변수는 global에 선언된 변수로 outer 함수뿐 아니라 다른 코드나 함수에서도 참조가 가능하다.

    각 스코프는 자신의 영역에 최대한 관심을 가지며, 다른 영약의 변수나 객체에 대해서는 제한적인 제어를 갖는다.


    """
    def greetings(x):
        def say_hi():
            print(x)

        say_hi()


    greetings('안녕하세요?')

    안녕하세요?
    """
    say_hi내부 함수는 nonlocal 영역의 x변수를 그대로 반환하는 기능을 갖고있다.
    그리고 greetings가 받은 문자열을 문제없이 참조할 수 있다.
    즉, 외부 스코프의 변수에 대해 '읽기'가 문제없이 가능하다.

    """
    def count(x):
        def increment():
            x += 1
            print(x)

        increment()


    >>> count(5)

    UnboundLocalError: local variable 'x' referenced before assignment
    """
    하지만, 자신의 영역이 아닌 영역에 대해 '쓰기'는 제한적이다.
    local 영역에서 밖의 영역에 대한 값을 참조하는, 또는 읽는 것은 항상 문제가 없는데, 값을 수정하거나 새로 할당하는 것은, 쓰는 것(write)은 안 된다.
    위에서는 ‘x += 1‘가 ‘수정하는’ 역할을 하고 있다. 파이썬에서는 값을 수정하는, 쓰는 코드가 나오면 따로 언급이 없는 한,
    increment 함수는 x 가 자신이 제어할 수 있는 local 변수라고 무조건 가정한다. 함부로 외부의 변수를 건드리는 어려운 버그를 막기 위해서다. 

    왜 위와 같이 헷갈리게 만들어놨을까? 그것은 코드 영역의 책임과 권한을 명확히 나누는 것이 좋기 때문이다. 
    예제의 count 함수는 하나의 내부 함수를 갖고 있지만, 어떤 경우에는 수십여개의 내부 함수를 가질 수도 있다. 
    이때 내부 함수마다 count의 상태값을 건드리고 수정한다면 예상하지 못한 결과를 초래할 수 있다. 


"""
def count(x):
    def increment():
        nonlocal x  # x가 로컬이 아닌 nonlocal의 변수임을 확인한다.
        x += 1
        print(x)

    increment()

count(5)

>>> 6
"""


의도적으로 nonlocal 스코프의 값을 수정하고 싶으면 어떻게 할까? 이때 nonlocal statement를 쓰면 된다.
increment 함수 정의 바로 아랫줄에 ‘nonlocal x‘라고 선언했다. 
이 코드는 x 가 local 변수가 아닌, nonlocal, 여기서는 count 스코프 내의 변수라는 것을 
개발자가 명시적으로 선언하는 것으로 nonlocal 영역의 상태에 대해 읽는 것뿐 아니라 쓰는 것도 가능하게 된다. 



3. 데코레이터란 무엇인가.


<추후에 계속>



4. labmda 식을 사용하는 이유
- 메모리 절약
- 가독성 향상 ~ 너무 람다식을 많이 사용하면 가독성이 떨어짐. 익명함수에 사용하는 것을 추천함.
- 코드 간결화

함수는 객체 생성 -> 리소스(메모리) 할당을 하지만
람다는 즉시 실행 (Heap 초기화) -> 메모리 초기화

tip)
    많은 메모리를 절약하진 않지만, 람다식은 
    (1) 데이터 전처리
    (2) 웹에서 사용하는 게시판 데이터를 DB에서 대량으로 가져와 
        날짜변경 - 데이터 수정 - 문자열 조합 등에 사용하면 좋다.